```public class SingleTon {    private static SingleTon singleTon = new SingleTon();    public static int count1;    public static int count2 = 0;    static {        System.out.println("静态代码块执行！");    }    public SingleTon() {        count1++;        count2++;    }    public static SingleTon getInstance() {        return singleTon;    }     public static void main(String[] args) {        SingleTon singleTon = SingleTon.getInstance();        System.out.println("count1=" + singleTon.count1);        System.out.println("count2=" + singleTon.count2);    }}```##### 输出结果:count1=1;count2=0## 分析1. SingleTon.getInstance(); 触发类的初始化2. 在类加载的准备阶段会为类的静态变量分配内存和初始化值，此阶段singleTon=null，count1=0，count2=03. <font color="#dd0000">**类初始化时，为类的静态变量赋值和执行静态代码快**</font><br />4. singleton赋值为new SingleTon(),调用类的构造方法,count1=1，count2=15. 继续为count1与count2赋值,count1没有赋值操作，则为1;count2 则赋值为0## 何时开始类的初始化* 创建类的实例* 访问类的静态变量(除常量【被final修辞的静态变量】* 访问类的静态方法* 反射如(Class.forName("my.xyz.Test"))* 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化* 虚拟机启动时，定义了main()方法的那个类先初始化###### 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构### 加载* 通过全类名获取类的二进制字节流* 将字节流所代表的静态存储结构转化为方法区的运行时数据结构* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的方法入口### 验证###### 目的：确保Class文件的字节流中包含的信息符合《JAVA虚拟机的》全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全1. 文件格式验证###### 目的是保证输入的字节流能够正确的解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求2. 元数据验证###### 目的是对类的元数据信息进行语义校验，保证不存在与《Java虚拟机》定义相悖的元数据信息3. 字节码验证###### 目的是通过数据流分析和控制分析，确定程序语义是合法的且符合逻辑4. 符号引用验证###### 目的是确保解析行为可以正常执行### 准备###### 为类的静态变量分配内存并设置变量初始值的阶段### 解析######  Java虚拟机将常量池内的符号引用替换为直接引用1. 类和接口的解析2. 字段解析3. 方法解析4. 接口方法解析### 初始化###### 初始化类静态变量和其他资源。还会执行静态代码块。初始化阶段就是执行类构造器clinit()方法的过程1. clinit()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由在源文件中出现的顺序决定的2. 在子类clinit()方法执行前，父类的clinit()方法会执行完毕3. 如果一个类或接口中没有静态语句块或变量赋值操作，编译器不会为这个类生成clinit()方法