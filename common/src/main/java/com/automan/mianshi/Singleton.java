package com.automan.mianshi;/** * @Author he.zhou * @Date 2021-03-29 */public class Singleton {    /**     *     *///    private static final Singleton SINGLETON = new Singleton();////    private Singleton() {////    }////    public static Singleton getSingleton() {//        return SINGLETON;//    }    private static volatile Singleton singleton;    private Singleton() {        if (singleton != null)            try {                throw new IllegalAccessException("单例对象已经被实例化，请不要非法反射构造函数");            } catch (IllegalAccessException e) {                e.printStackTrace();            }    }    /**     * 此处使用volatile是禁止指令重排     * new Singleton();分为三步     * 1.给Singleton分配内存空间     * 2.调用Singleton的构造函数初始化成员变量     * 3.将singleton对象指向分配的内存空间（这一步执行完就singleton就会费null）     * JVM在即时编译器中存在指令重排序的优化，假如第二步与第三部互换后，就会导致第二个线程过来判断singleton！=null，直接返回了。但是未完成初始化的对象，使用时就会报错     * <p>     * 第二次检查是因为会有多个线程在synchronized()外等待，假如不做双检查，会生成多个对象     *     * @return     *///    public static Singleton getSingleton() {//        if (singleton == null) {//            synchronized (Singleton.class) {//                if (singleton == null) {//                    singleton = new Singleton();//                }//            }//        }//        return singleton;//    }    private static class inner {        private static volatile Singleton singleton = new Singleton();    }    public static Singleton getSingleton() {        return inner.singleton;    }    public static void main(String[] args) {        Singleton.getSingleton();    }}